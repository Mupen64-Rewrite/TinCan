// Fast resource generator. Could be sped up with some kind of
// vectorization, but I am NOT doing that.

#include <filesystem>
#include <fstream>
#include <iomanip>
#include <ios>
#include <iostream>
#include <memory>
#include <string>
#include <array>
#include <string_view>
#include <syncstream>
#include <vector>

#include <fmt/core.h>

using namespace std::string_view_literals;
namespace fs = std::filesystem;

constexpr std::string_view operator""_txt(const char* data, size_t len) {
  return std::string_view(data + 1, len - 2);
}

constexpr auto data_header = R"(
// File generated by rc.cpp
#include "{2}"
#include <cstddef>
#include <cstdint>
namespace {0}{{const uint8_t _data_{1}[] = {{
)"_txt;
constexpr auto data_footer = R"(
}};const size_t _size_{0} = {1};}}
)"_txt;

constexpr auto decl_pattern = R"(
#include <cstddef>
#include <cstdint>
namespace {0} {{
  extern const size_t _size_{1};
  extern const uint8_t _data_{1}[];
}}
)"_txt;

int main(int argc, char* argv[]) {
  std::ios_base::sync_with_stdio(false);
  if (argc != 6) {
    fputs("Incorrect arguments", stderr);
    return 1;
  }

  fs::path in_path = argv[1];
  size_t in_size   = fs::file_size(in_path);
  auto in_data     = std::make_unique<char[]>(in_size);
  {
    std::ifstream stream(in_path, std::ios_base::binary);
    stream.read(in_data.get(), in_size);
  }
  
  fs::path out_path = argv[2];
  fs::path outh_path = argv[5];
  std::string_view ns = argv[3];
  std::string_view name = argv[4];
  {
    std::ofstream out(out_path);
    
    auto it = std::ostreambuf_iterator(out);
    // add header
    fmt::format_to(it, 
      data_header, ns, name, outh_path.generic_string());
      
    // scalar version
    for (int i = 0; i < in_size; i++) {
      fmt::format_to(it, "{:d},", uint8_t(in_data[i]));
    }
    
    fmt::format_to(it, data_footer, name, in_size);
  }
  
  {
    std::ofstream out(outh_path);
    fmt::format_to(std::ostreambuf_iterator(out), decl_pattern, ns, name);
  }
}